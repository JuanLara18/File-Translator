"""
Translation Script

This script reads Excel (.xlsx) or Stata (.dta) files, translates specified columns from German
to English using the OpenAI API, and writes out a new file with all original data plus
additional columns containing English translations.

Usage:
    python enhanced_translation.py --input input_file.[xlsx|dta] --column German_Text [--output output_file.[xlsx|dta]] [--batch_size 10]

If the output file is not specified, it will be automatically generated by appending '_translated'
to the input file's name.
"""

import os
import sys
import argparse
import logging
import datetime
from typing import Union, Tuple
from dotenv import load_dotenv
import pandas as pd
from tqdm import tqdm
from openai import OpenAI

# -----------------------
# Configuration and Setup
# -----------------------

# Set up logging
script_dir = os.path.dirname(os.path.abspath(__file__))
logging.basicConfig(
    filename=os.path.join(script_dir, 'translation.log'),
    filemode='a',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Load environment variables from .env file
load_dotenv("OPENAI_API_KEY.env")
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
if not OPENAI_API_KEY:
    logging.error("OpenAI API key not found in environment variables.")
    raise ValueError("OpenAI API key not found in environment variables. Please set it in your .env file.")

# Initialize OpenAI client
client = OpenAI(api_key=OPENAI_API_KEY)

# Global constants
MODEL_NAME = 'gpt-3.5-turbo'
SYSTEM_MESSAGE = "You are a helpful assistant that translates German text into English."
TRANSLATION_PROMPT = "Translate the following text from German to English:\n\n"

SUPPORTED_FORMATS = {'.xlsx': 'excel', '.dta': 'stata'}

# -----------------------
# Functions
# -----------------------

def extract_translation(response_text: str) -> tuple[str, bool]:
    """
    Extracts translation from a formatted response.
    Returns the translation and a boolean indicating if the format was correct.
    
    :param response_text: The response text from the API
    :return: Tuple of (translation, is_valid_format)
    """
    try:
        # Check if response follows the exact format we expect
        if "TRANSLATION:" in response_text:
            # Split by TRANSLATION: and take the part after it
            parts = response_text.split("TRANSLATION:")
            if len(parts) == 2:
                translation = parts[1].strip()
                # Verify no explanatory text or quotes were added
                if not any(marker in translation for marker in 
                    ["means", "translates", "translation", "in English", '"', "'", "[", "]", "(", ")"]):
                    return translation, True
        return response_text, False
    except Exception as e:
        logging.error(f"Error extracting translation: {e}")
        return response_text, False

def create_translation_cache(df: pd.DataFrame, column: str) -> dict:
    """
    Creates a cache of unique texts to translate to avoid redundant API calls.
    
    :param df: DataFrame containing the texts to translate
    :param column: Name of the column containing texts to translate
    :return: Dictionary mapping unique texts to their frequency
    """
    return df[column].value_counts().to_dict()

def translate_text(text: str, translation_cache: dict = None) -> str:
    """
    Translates text from German to English, optimized for machine error descriptions.
    Uses caching to avoid redundant translations.
    
    :param text: A string in German to translate
    :param translation_cache: Cache of previous translations
    :return: The English translation as a string
    """
    if not isinstance(text, str) or not text.strip():
        return text

    system_message = """You are a technical translator specializing in machine error messages and technical descriptions. Follow these rules:

1. Translate from German to English precisely and technically
2. Use consistent technical terminology
3. Maintain any error codes or numbers exactly as they appear
4. Keep punctuation that could be part of error syntax
5. Do not add explanations or alternatives
6. Do not modify technical terms in brackets or parentheses
7. Preserve any variable names or placeholders exactly as they appear

Example 1:
Input: "Fehler E123: Motorüberhitzung"
Output: Error E123: Motor overheating

Example 2:
Input: "Wartung erforderlich: Öldruck niedrig [P045]"
Output: Maintenance required: Oil pressure low [P045]

Respond ONLY with the direct translation, nothing else."""

    try:
        # Check cache first if provided
        if translation_cache is not None and text in translation_cache:
            return translation_cache[text]

        response = client.chat.completions.create(
            model=MODEL_NAME,
            messages=[
                {"role": "system", "content": system_message},
                {"role": "user", "content": f"Translate: {text}"}
            ],
            temperature=0.1,
            max_tokens=1000  # Reduced as error messages are typically short
        )

        translated_text = response.choices[0].message.content.strip()
        
        # Clean the translation while preserving technical elements
        translated_text = (translated_text
                         .replace('"', '')
                         .replace("'", "")
                         .replace(" translates to ", "")
                         .replace(" means ", "")
                         .replace(" in English", "")
                         .replace("Translation: ", "")
                         .strip())

        # Update cache if provided
        if translation_cache is not None:
            translation_cache[text] = translated_text

        logging.info(f"Translated: {text} → {translated_text}")
        return translated_text

    except Exception as e:
        logging.error(f"Translation error for '{text}': {str(e)}")
        return text

def process_files(input_file: str, output_file: str, translate_col: str, 
                new_col_name: str = "Translation", batch_size: int = 10):
    """
    Processes Excel or Stata files by translating the content of the specified column.
    Uses caching for efficiency with repeated texts and preserves file-specific metadata.
    
    Args:
        input_file (str): Path to the input file (Excel or Stata)
        output_file (str): Path where the translated file will be saved
        translate_col (str): Name or letter of the column to translate
        new_col_name (str, optional): Name for the translated column. Defaults to "Translation"
        batch_size (int, optional): Number of texts to process at once. Defaults to 10
    
    Raises:
        ValueError: If the column identifier is invalid
        Exception: For file reading/writing errors or translation issues
    """
    try:
        # Determine file type from extension
        file_extension = os.path.splitext(input_file)[1].lower()
        
        # Read file based on type
        if file_extension in ['.xlsx', '.xls']:
            df = pd.read_excel(input_file)
            stata_meta = None
            logging.info(f"Loaded Excel file: {input_file} with {len(df)} rows.")
        elif file_extension == '.dta':
            try:
                # Read Stata file with metadata
                df = pd.read_stata(input_file, convert_categoricals=False)
                # Store all metadata
                stata_meta = {
                    'value_labels': df.value_labels() if hasattr(df, 'value_labels') else {},
                    'variable_labels': df.variable_labels() if hasattr(df, 'variable_labels') else {},
                    'formats': {col: df[col].dtype for col in df.columns},
                    'value_label_dict': {}
                }
                
                # Store value label mappings for each variable
                for col in df.columns:
                    if hasattr(df[col], 'cat') and hasattr(df[col].cat, 'categories'):
                        stata_meta['value_label_dict'][col] = dict(zip(
                            df[col].cat.categories,
                            df[col].cat.categories
                        ))
                
                logging.info(f"Loaded Stata file: {input_file} with {len(df)} rows and metadata.")
            except Exception as e:
                logging.warning(f"Could not load complete Stata metadata: {e}")
                df = pd.read_stata(input_file)
                stata_meta = None
                logging.info(f"Loaded Stata file without metadata: {input_file} with {len(df)} rows.")
        else:
            raise ValueError(f"Unsupported file type: {file_extension}")

        # Validate column - handle both name and Excel letter notation
        if translate_col not in df.columns:
            try:
                # Convert Excel column letter to index (A=0, B=1, etc.)
                col_index = ord(translate_col.upper()) - ord('A')
                if 0 <= col_index < len(df.columns):
                    translate_col = df.columns[col_index]
                    logging.info(f"Column letter '{translate_col}' converted to name: {translate_col}")
                else:
                    raise ValueError(f"Column letter '{translate_col}' is out of range")
            except Exception as e:
                logging.error(f"Invalid column identifier '{translate_col}': {e}")
                raise ValueError(f"Invalid column identifier '{translate_col}'.")

        # Create translation cache and get unique texts
        translation_cache = {}
        unique_texts = df[translate_col].value_counts()
        logging.info(f"Found {len(unique_texts)} unique texts to translate.")

        # Translate unique texts with progress bar
        unique_translations = {}
        for text, count in tqdm(unique_texts.items(), desc="Translating unique texts"):
            if pd.notna(text):  # Skip NaN values
                translated = translate_text(str(text), translation_cache)
                unique_translations[text] = translated
                logging.info(f"Translated text (appears {count} times): {text} → {translated}")

        # Apply translations to DataFrame using the cache
        df[new_col_name] = df[translate_col].map(lambda x: unique_translations.get(x, x) if pd.notna(x) else x)

        # Save file based on type
        if file_extension in ['.xlsx', '.xls']:
            df.to_excel(output_file, index=False)
            logging.info(f"Saved translated Excel file to: {output_file}")
        else:  # .dta
            try:
                if stata_meta:
                    # Update variable labels to include the new translation column
                    if 'variable_labels' in stata_meta:
                        original_label = stata_meta['variable_labels'].get(translate_col, translate_col)
                        stata_meta['variable_labels'][new_col_name] = f"English translation of: {original_label}"
                    
                    # Save with preserved metadata
                    df.to_stata(
                        output_file,
                        write_index=False,  # Prevent index column from being written
                        variable_labels=stata_meta['variable_labels'],
                        value_labels=stata_meta['value_labels'],
                        version=118
                    )
                else:
                    # If no metadata, save without index
                    df.to_stata(output_file, write_index=False, version=118)
                logging.info(f"Saved translated Stata file to: {output_file}")
            except Exception as e:
                logging.error(f"Error saving Stata file: {e}")
                # Fallback to saving without metadata
                df.to_stata(output_file, write_index=False, version=118)
                logging.info(f"Saved translated Stata file without metadata to: {output_file}")

        # Log translation statistics
        total_texts = len(df)
        unique_text_count = len(unique_translations)
        saved_calls = total_texts - unique_text_count
        
        logging.info("Translation statistics:")
        logging.info(f"Total texts processed: {total_texts}")
        logging.info(f"Unique texts translated: {unique_text_count}")
        logging.info(f"API calls saved through caching: {saved_calls}")
        
        return df, unique_translations  # Return for potential further processing

    except Exception as e:
        logging.error(f"Error processing file: {e}")
        raise  # Raise instead of sys.exit() to allow proper error handling by caller

def generate_output_filename(input_file: str) -> str:
    """
    Generates an output filename by appending '_translated' before the file extension.
    
    :param input_file: The input file name.
    :return: The generated output file name.
    """
    base, ext = os.path.splitext(input_file)
    return f"{base}_translated{ext}"

def parse_args():
    """
    Parses command-line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Translate a specified column in the file from German to English."
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to the input file."
    )
    parser.add_argument(
        "--output",
        help="Path to the output file. If not provided, the script will auto-generate one."
    )
    parser.add_argument(
        "--column",
        required=True,
        help="Column to translate (can be a column name or a letter, e.g., 'B')."
    )
    parser.add_argument(
        "--new_col",
        default="Translation",
        help="Name of the new column to hold the English translation. Default is 'Translation'."
    )
    parser.add_argument(
        "--batch_size",
        type=int,
        default=10,
        help="Number of rows to process at a time. Default is 10."
    )
    return parser.parse_args()

# -----------------------
# Main Execution
# -----------------------

if __name__ == "__main__":
    args = parse_args()

    # Determine the output file name if not specified
    output_file = args.output if args.output else generate_output_filename(args.input)

    start_time = datetime.datetime.now()
    logging.info("Starting translation process.") 

    process_files(  # Changed from process_excel
        input_file=args.input,
        output_file=output_file,
        translate_col=args.column,
        new_col_name=args.new_col,
        batch_size=args.batch_size
    )

    end_time = datetime.datetime.now()
    elapsed_time = (end_time - start_time).total_seconds()
    print(f"Translation completed in {elapsed_time:.2f} seconds. Output saved to {output_file}.")
    logging.info(f"Translation process finished in {elapsed_time:.2f} seconds.")